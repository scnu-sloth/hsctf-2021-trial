## DoubleEnc

题目实现了一个新的加密算法，用DES加密了两次，而且两个DES的密钥还是不一样的。

先确定已有的几个基本信息：

1. 已知一对明密文；
2. 明文进行了两次DES加密，得到密文；
3. 两个DES的密钥不相同；
4. 已知第一个密钥的第一个字节为字符A，第二个密钥的最后一个字节为字符!；
5. DES的密钥长度是8个字节；
6. 两个密钥拼起来就是flag；
7. 已知flag的bcrypt值。

注意，flag中的字符都是可打印字符，也就是每个字符的ascii码都是在[32, 126]这个区间中的。如果我们要枚举密钥的话，是不需要枚举(2^8)^8这么多密钥的，只有(96)^8。同时，由第四个信息可知：实际枚举量应该是(96)^6。但是，这个量仍然非常大。

这里采用的思想是中间相遇法。先枚举key1，用每一个key1去对明文进行一次DES加密，也就是得到所有可能的text的值。把它们都存为一张表，和所用的key1一一对应。在python中可以用dict，C++的话，就用unordered_map了。这一步会生成一个非常大的表，需要比较大的内存。

然后，枚举key2，用每一个key2去对密文进行一次DES解密，得到text的值，然后在上一步得到的表中查询这个text值对应的key1。如果能查询到，那说明当前的key1和key2组合起来很可能就是flag了；如果查询不到，说明当前的key2是错误的。**注意**，这一步并不需要将text存起来，而是算出一个查一个，不需要占用内存。根据第七个信息点，再对所有可能的flag进行检查，找出正确的那个。

本题解虽然也是采用枚举密钥的方法，但是，由于密钥被先预处理掉一半了，最终整个时间复杂度大大降低。这个方法的代价是，需要较大的内存空间。是一种空间换时间的技巧。

为了不浪费选手太多时间，出题人在代码中留下的hint可以大幅度减少枚举量，使用普通的4G内存的电脑，就可以轻松地完成解题。当然，直接暴力枚举(96)^6个密钥也是可行的，只是无法在规定时间内完成而已。



